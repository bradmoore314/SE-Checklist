Instructions for Replit AI
To fix the problems where markers drift from their intended positions and do not scale correctly during zooming in the EnhancedFloorplanViewer component, please apply the following modifications. These changes will synchronize the SVG layer with the canvas, maintain marker positions, and ensure proper scaling behavior.

1. Synchronize viewportDimensions with Scale Changes
The primary issue appears to be a timing mismatch: when the zoom level (scale) changes, the viewportDimensions (used to size the SVG and canvas) may not update immediately, causing the SVG layer to misalign with the PDF content on the canvas. To fix this, update viewportDimensions synchronously whenever scale changes, using the PDF dimensions at scale 1 (pdfDimensions).

Action: Add a useEffect hook to recalculate viewportDimensions based on scale and pdfDimensions.
Location: Inside the EnhancedFloorplanViewer component, after state declarations but before the renderPage function.
Code:
typescript

Copy
useEffect(() => {
  if (pdfDimensions.width && pdfDimensions.height) {
    setViewportDimensions({
      width: pdfDimensions.width * scale,
      height: pdfDimensions.height * scale
    });
  }
}, [scale, pdfDimensions, setViewportDimensions]);
Explanation:
pdfDimensions represents the PDF’s width and height at scale = 1, set during renderPage using page.getViewport({ scale: 1 }).
When scale changes (e.g., during a zoom event), viewportDimensions should reflect the scaled size of the PDF immediately (pdfDimensions.width * scale).
This ensures the SVG layer (which uses viewportDimensions for its width and height) matches the canvas size during zoom transitions, preventing marker drift.
The dependency array includes setViewportDimensions to satisfy React’s exhaustive-deps lint rule, assuming it’s a state setter from useState.
Note: The existing renderPage function already updates viewportDimensions asynchronously after rendering the PDF page. This useEffect provides an immediate approximation, reducing misalignment until renderPage completes.
2. Verify and Adjust Marker Rendering
Markers must behave differently based on their type:

Point markers (e.g., access_point, camera) should maintain a constant visual size on the screen, regardless of zoom level, for visibility and usability.
Area markers (e.g., rectangle, ellipse) should scale with the PDF content to remain proportional to the floorplan.
Action: Review and adjust the SVG rendering logic for each marker type.
Location: Inside the SVG element where markers are rendered (typically a map or similar loop over markers or layers).
Code Adjustments:
For Point Markers (e.g., access_point):
typescript

Copy
<g transform={`translate(${marker.position_x}, ${marker.position_y})`}>
  <circle
    r={12 / scale}
    fill={marker.fill ?? "rgba(255, 0, 0, 0.5)"}
    stroke="black"
    strokeWidth={1 / scale}
  />
  {marker.label && (
    <text
      x={0}
      y={0}
      fontSize={14 / scale}
      textAnchor="middle"
      dominantBaseline="middle"
      fill="black"
    >
      {marker.label}
    </text>
  )}
</g>
Explanation:
Position: Use marker.position_x and marker.position_y directly (in PDF coordinates) since the SVG’s transform (scale(${scale})) handles scaling.
Size: Divide sizes by scale (e.g., r={12 / scale}, fontSize={14 / scale}) to counteract the SVG’s scaling, keeping the circle and text size constant in screen space.
Stroke: Adjust strokeWidth={1 / scale} for consistent line thickness.
For Area Markers (e.g., rectangle):
typescript

Copy
<g>
  <rect
    x={marker.position_x}
    y={marker.position_y}
    width={marker.width}
    height={marker.height}
    fill={marker.fill ?? "rgba(0, 0, 255, 0.3)"}
    stroke="black"
    strokeWidth={2}
  />
</g>
Explanation:
Position and Size: Use marker.position_x, marker.position_y, marker.width, and marker.height directly (in PDF coordinates). The SVG’s scale(${scale}) transform scales these proportionally with the PDF.
Stroke: Keep strokeWidth constant (e.g., 2) if a fixed screen-space thickness is desired, or leave it unadjusted to scale with the PDF (adjust based on user preference).
Verification: Check all marker types in your renderMarker function or equivalent. Ensure point markers use 1/scale for sizes, while area markers do not unless constant screen size is explicitly required.
3. Validate Coordinate Transformations
Ensure that marker positions remain consistent by verifying the coordinate transformation logic, especially during mouse interactions and rendering.

Action: Review the CoordinateSystem class methods used in the component.
Code to Check:
pdfToScreenCoordinates (or equivalent):
typescript

Copy
pdfToContainer(pdfX: number, pdfY: number): Point {
  const containerX = pdfX * this.scale + this.translateX;
  const containerY = pdfY * this.scale + this.translateY;
  return { x: containerX, y: containerY };
}
screenToPdfCoordinates (or equivalent):
typescript

Copy
containerToPdf(containerX: number, containerY: number): Point {
  const pdfX = (containerX - this.translateX) / this.scale;
  const pdfY = (containerY - this.translateY) / this.scale;
  return { x: pdfX, y: pdfY };
}
Usage:
Rendering: Confirm that marker positions are in PDF coordinates and rendered directly in the SVG, relying on the SVG’s transform: translate(${translateX}px, ${translateY}px) scale(${scale}).
Mouse Events: In handleMouseDown or similar, ensure mouse coordinates are converted to PDF coordinates using screenToPdfCoordinates when adding or moving markers.
typescript

Copy
const rect = containerRef.current?.getBoundingClientRect();
if (rect) {
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const pdfPoint = coordSystem.containerToPdf(mouseX, mouseY);
  // Use pdfPoint.x, pdfPoint.y for marker positions
}
Explanation: The SVG and canvas share the same transform, so markers at PDF coordinates (e.g., marker.position_x) should align correctly when the SVG is scaled and translated. Any drift suggests a mismatch, but the useEffect fix should address this by keeping viewportDimensions consistent.
4. Test and Refine
Test Cases:
Zoom in and out using the mouse wheel; verify that point markers (e.g., circles) stay in place and maintain size, while area markers (e.g., rectangles) scale with the PDF.
Add a new marker at various zoom levels; ensure its position matches the clicked location on the PDF.
Adjustments:
If minor drift persists, double-check calculateZoomTransform:
typescript

Copy
calculateZoomTransform(mouseX: number, mouseY: number, newScale: number) {
  const mousePdfX = (mouseX - this.translateX) / this.scale;
  const mousePdfY = (mouseY - this.translateY) / this.scale;
  const newTranslateX = mouseX - mousePdfX * newScale;
  const newTranslateY = mouseY - mousePdfY * newScale;
  return { scale: newScale, translateX: newTranslateX, translateY: newTranslateY };
}
Ensure translateX and translateY keep the mouse point fixed during zoom.
Expected Outcome
Marker Positioning: Markers will stay aligned with their corresponding PDF locations during zoom, thanks to immediate viewportDimensions updates.
Marker Scaling: Point markers will maintain a consistent screen size (e.g., a 12-pixel radius circle), while area markers will scale proportionally with the PDF, improving usability and visual coherence.
User Experience: A smoother, more reliable zooming experience without noticeable drift or resizing issues.
Please implement these changes in the EnhancedFloorplanViewer component and test thoroughly to confirm the fixes resolve the reported issues. Let me know if further clarification is needed!